
import { BoardState, Player, Position, Difficulty } from '../types';
import { BOARD_SPECS, BOARD_COUNT } from '../constants';

// --- Coordinate Mapping ---
// We map everything to a Global Coordinate System for line generation
// Global Z = Sum of previous board depths + local Z

const TOTAL_GLOBAL_Z = BOARD_SPECS.reduce((acc, spec) => acc + spec.depth, 0);
const MAX_ROWS = Math.max(...BOARD_SPECS.map(s => s.rows));
const MAX_COLS = Math.max(...BOARD_SPECS.map(s => s.cols));

export interface GlobalPosition extends Position {
  boardId: number;
}

const ALL_LINES: GlobalPosition[][] = [];
const addLine = (line: GlobalPosition[]) => ALL_LINES.push(line);

// --- Generate Lines ---

const mapGlobalToLocal = (gx: number, gy: number, gz: number): GlobalPosition | null => {
  let currentZBase = 0;
  
  for (let i = 0; i < BOARD_COUNT; i++) {
    const spec = BOARD_SPECS[i];
    
    // Check if Z falls in this board's range
    if (gz >= currentZBase && gz < currentZBase + spec.depth) {
      const localZ = gz - currentZBase;
      
      // Check if X and Y fit in this board's dimensions
      if (gx >= 0 && gx < spec.cols && gy >= 0 && gy < spec.rows) {
        return { x: gx, y: gy, z: localZ, boardId: i };
      } else {
        return null; // Point is outside this board's X/Y bounds
      }
    }
    currentZBase += spec.depth;
  }
  return null;
};

// 1. GENERATE GLOBAL EUCLIDEAN LINES (Standard 4x4x8 Space)
// This covers Arena 1, Standard Arena 2, and Vertical/Diagonal connections between them.
for (let z = 0; z < TOTAL_GLOBAL_Z; z++) {
  for (let y = 0; y < MAX_ROWS; y++) {
    for (let x = 0; x < MAX_COLS; x++) {
      
      const directions = [
        { dx: 1, dy: 0, dz: 0 }, 
        { dx: 0, dy: 1, dz: 0 }, 
        { dx: 0, dy: 0, dz: 1 }, 
        { dx: 1, dy: 1, dz: 0 }, 
        { dx: 1, dy: -1, dz: 0 },
        { dx: 1, dy: 0, dz: 1 }, 
        { dx: 1, dy: 0, dz: -1 },
        { dx: 0, dy: 1, dz: 1 }, 
        { dx: 0, dy: 1, dz: -1 },
        { dx: 1, dy: 1, dz: 1 }, 
        { dx: 1, dy: 1, dz: -1 },
        { dx: 1, dy: -1, dz: 1 }, 
        { dx: 1, dy: -1, dz: -1 },
      ];

      for (const { dx, dy, dz } of directions) {
        const line: GlobalPosition[] = [];
        let validLine = true;

        for (let step = 0; step < 4; step++) { // WIN CONDITION IS 4
          const cx = x + (dx * step);
          const cy = y + (dy * step);
          const cz = z + (dz * step);

          const pos = mapGlobalToLocal(cx, cy, cz);
          
          if (!pos) {
            validLine = false;
            break;
          }
          line.push(pos);
        }

        if (validLine) {
          addLine(line);
        }
      }
    }
  }
}

// 2. GENERATE TOROIDAL LINES FOR ARENA 2 (Wrapping Logic)
// Arena 2 is Board ID 1. It wraps on X, Y, and Z axes internally.
const ARENA_2_ID = 1;
const a2Spec = BOARD_SPECS[ARENA_2_ID];

for (let z = 0; z < a2Spec.depth; z++) {
  for (let y = 0; y < a2Spec.rows; y++) {
    for (let x = 0; x < a2Spec.cols; x++) {
       // Only need to check positive directions because of wrapping
       const directions = [
        { dx: 1, dy: 0, dz: 0 }, 
        { dx: 0, dy: 1, dz: 0 }, 
        { dx: 0, dy: 0, dz: 1 }, 
        { dx: 1, dy: 1, dz: 0 }, 
        { dx: 1, dy: -1, dz: 0 },
        { dx: 1, dy: 0, dz: 1 }, 
        { dx: 1, dy: 0, dz: -1 },
        { dx: 0, dy: 1, dz: 1 }, 
        { dx: 0, dy: 1, dz: -1 },
        { dx: 1, dy: 1, dz: 1 }, 
        { dx: 1, dy: 1, dz: -1 },
        { dx: 1, dy: -1, dz: 1 }, 
        { dx: 1, dy: -1, dz: -1 },
      ];

      for (const { dx, dy, dz } of directions) {
        const line: GlobalPosition[] = [];
        
        for (let step = 0; step < 4; step++) {
          // Calculate Wrapped Coordinates
          // We use modulo arithmetic to wrap around 0-3
          let nx = (x + (dx * step)) % a2Spec.cols;
          let ny = (y + (dy * step)) % a2Spec.rows;
          let nz = (z + (dz * step)) % a2Spec.depth;

          // Handle negative modulo correctly in JS
          if (nx < 0) nx += a2Spec.cols;
          if (ny < 0) ny += a2Spec.rows;
          if (nz < 0) nz += a2Spec.depth;

          line.push({ x: nx, y: ny, z: nz, boardId: ARENA_2_ID });
        }

        // Add ALL generated lines. We rely on the dedup Set below to filter out
        // standard lines that were already generated by the Euclidean loop.
        // This ensures we don't miss any wrapping configurations.
        addLine(line);
      }
    }
  }
}


// Deduplicate lines
const uniqueLines = new Set<string>();
const DEDUPED_LINES: GlobalPosition[][] = [];

ALL_LINES.forEach(line => {
  // Sort points to ensure order doesn't matter for uniqueness check (A-B-C-D is same as D-C-B-A or unordered set)
  // We use sorting to create a canonical key for the set of points.
  const key = line.map(p => `${p.boardId},${p.x},${p.y},${p.z}`).sort().join('|');
  if (!uniqueLines.has(key)) {
    uniqueLines.add(key);
    DEDUPED_LINES.push(line);
  }
});

// --- Game Functions ---

export const createEmptyBoards = (): BoardState[] => {
  return BOARD_SPECS.map(spec => 
    Array.from({ length: spec.cols }, () =>
      Array.from({ length: spec.rows }, () =>
        Array.from({ length: spec.depth }, () => null)
      )
    )
  );
};

export const createEmptyBoard = (): BoardState => {
  // Fallback for single board init if needed, defaulting to standard
  return createEmptyBoards()[0];
};


export const checkWin = (boards: BoardState[]): { winner: Player | null; lines: GlobalPosition[][] } => {
  const winningLines: GlobalPosition[][] = [];
  let winner: Player | null = null;

  for (const line of DEDUPED_LINES) {
    const p0 = line[0];
    const firstVal = boards[p0.boardId][p0.x][p0.y][p0.z];

    if (firstVal) {
      if (line.every(p => boards[p.boardId][p.x][p.y][p.z] === firstVal)) {
        winner = firstVal;
        winningLines.push(line);
      }
    }
  }

  return { winner, lines: winningLines };
};

// --- AI Logic ---

interface ScoredMove {
  boardId: number;
  pos: Position;
  score: number;
}

const getLinesPassingThrough = (boardId: number, x: number, y: number, z: number): GlobalPosition[][] => {
  return DEDUPED_LINES.filter(line => 
    line.some(p => p.boardId === boardId && p.x === x && p.y === y && p.z === z)
  );
};

const evaluateMove = (
  boards: BoardState[], 
  boardId: number,
  x: number, 
  y: number, 
  z: number, 
  player: 'O', 
  opponent: 'X'
): number => {
  let score = 0;
  const lines = getLinesPassingThrough(boardId, x, y, z);

  for (const line of lines) {
    let playerCount = 0;
    let opponentCount = 0;
    
    for (const p of line) {
      if (p.boardId === boardId && p.x === x && p.y === y && p.z === z) continue;
      const val = boards[p.boardId][p.x][p.y][p.z];
      if (val === player) playerCount++;
      if (val === opponent) opponentCount++;
    }

    if (playerCount === 3 && opponentCount === 0) return 1000000; // Win
    if (opponentCount === 3 && playerCount === 0) score += 50000; // Block
    if (playerCount === 2 && opponentCount === 0) score += 1000;
    if (opponentCount === 2 && playerCount === 0) score += 500;
    if (playerCount === 1 && opponentCount === 0) score += 100;

    const uniqueBoards = new Set(line.map(p => p.boardId));
    if (uniqueBoards.size > 1) score += 100; // Cross-board moves are valuable/tricky

    if (boardId === 0) {
      const spec = BOARD_SPECS[boardId];
      const midX = (spec.cols - 1) / 2;
      const midY = (spec.rows - 1) / 2;
      const midZ = (spec.depth - 1) / 2;
      
      const dist = Math.abs(midX - x) + Math.abs(midY - y) + Math.abs(midZ - z);
      score += (20 - dist);
    } else {
      score += Math.random() * 5;
    }
  }

  return score;
};

export const getAiMove = (
  boards: BoardState[], 
  difficulty: Difficulty,
  blockedCells: Set<string>[]
): { boardId: number, pos: Position } => {
  const possibleMoves: ScoredMove[] = [];

  for (let bId = 0; bId < BOARD_COUNT; bId++) {
    const spec = BOARD_SPECS[bId];
    const board = boards[bId];
    
    for (let x = 0; x < spec.cols; x++) {
      for (let y = 0; y < spec.rows; y++) {
        for (let z = 0; z < spec.depth; z++) {
          
          const key = `${x}-${y}-${z}`;
          if (!board[x][y][z] && !blockedCells[bId].has(key)) {
            let score = evaluateMove(boards, bId, x, y, z, 'O', 'X');
            
            if (difficulty === Difficulty.EASY) score = Math.random() * 100;
            else if (difficulty === Difficulty.MEDIUM) score += Math.random() * 200;
            else score += Math.random() * 10;

            possibleMoves.push({ boardId: bId, pos: { x, y, z }, score });
          }
        }
      }
    }
  }

  possibleMoves.sort((a, b) => b.score - a.score);

  if (possibleMoves.length > 0) {
    return { boardId: possibleMoves[0].boardId, pos: possibleMoves[0].pos };
  }

  return { boardId: 0, pos: { x: 0, y: 0, z: 0 } };
};
